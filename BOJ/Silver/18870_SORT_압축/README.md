## 풀이 과정
  - 결과적으로 봤을 때, **(1)입력 시 data가 위치하던 index값**, **(2)data값**, **(3)sort후 data의 index값** 3가지의 값이 필요하다.
  - sort를 두번해준다.
  - (1)과 (3)을 연결지어주는 것이 관건이다.

## 구현의 문제
  - 입력 시에 data가 위치하던 index 값, data 값, sort후 data의 index 값 3종류를 갖고 있는 struct를 구현했다.
  - 구현한 struct의 배열에 대해서 sort를 사용하려 했지만 불가능했다. 
  - 이유는, **struct1 < struct2의 값을 비교하는 연산이 가능해야 sort 할 수 있는데, 그것을 정의해주지 않았기** 때문이다.
  - 이후에 struct에서 class로 구현방식을 바꿔서 연산자 오버로딩을 가능하게 하여 문제를 해결했다.
  - **struct끼리도, 연산자 오버로딩이 찾아보니 가능**하더라. 확인해보자.

## SORT에 대해서
  - sort의 대상이 되는 항목들의 <, >에 의한 연산이 가능해야 함을 인지해야 한다
    - 즉, **특정 자료형에 대한 <, > 연산이 가능하도록 만들어줘야 한다!**
  - 그래서, 복잡한 항목들의 비교에 대해서는 연산자 오버로딩을 자유자재로 이용할 줄 알아야 한다.
