# 이분탐색

## 정렬된 조건과 log 시간의 탐색

![image](https://user-images.githubusercontent.com/59442344/133200241-60b116f2-25a3-460a-8f95-27d717abdccf.png)

- 위의 그림을 잘 기억해봅시다.

### [경우 1] 조건을 만족하는 값의 범위중 가장 작은 값

- left, mid, right
- left <= right 인 경우 탐색 지속
- mid값 < 기준값 : left = mid + 1
- 기준값 <= mid값 : right = mid - 1

### [경우 2] 조건을 만족하는 값의 범위중 가장 큰 값

- left, mid, right
- left <= right 인 경우 탐색 지속
- 기준값 < mid값 : right = mid - 1
- mid값 <= 기준값 : left = mid + 1

### [STL] lower_bound, upper_bound

- 배열은 기본적으로 정렬되어 있어야 함
- algorithm 라이브러리 include 필요
- lower_bound : **찾고자 하는 값 n 이상의 숫자**가 몇 번째 인덱스에서 처음으로 등장하는지 찾기
- upper_bound : **찾고자 하는 값 n 초과의 숫자**가 몇 번째 인덱스에서 처음으로 등장하는지 찾기

```cpp
// arr에서 5 초과하는 수가 몇번째 인덱스에서 처음으로 나오는가
cout << upper_bound(&arr[0], &arr[N], 5) - arr << endl;

// arr에서 5 이상의 수가 몇번째 인덱스에서 처음으로 나오는가
cout << lower_bound(&arr[0], &arr[N], 5) - arr << endl;

// arr에서 5가 몇번 반복되는가
cout << upper_bound(&arr[0], &arr[N], 5) - lower_bound(&arr[0], &arr[N], 5) << endl;
```

## 최적화 문제를 결정 문제로

- 최적의 값을 구하는 최적화 문제를 결정 문제로 바꿀 때 사용한다. 즉, **이분탐색의 대상을 결정하여 해결하는 문제**로 바꿀 수 있다.
- 다음과 같은 예시들이 이에 해당한다.
    - 잘린 통나무 중 가장 긴 덩어리의 최소 값을 구하시오 = 잘린 통나무 길이를 기준으로 이분탐색을 하세요 : 1114
    - 가장 가까운 두 공유기의 최대 거리를 구하시오 = 공유기간 거리를 기준으로 이분탐색을 하세요 : 2110
    - 잘라내어 가장 길게 만들 수 있는 랜선의 길이를 구하시오 = 랜선 길이를 기준으로 이분탐색을 하세요 : 1654
    - 휴게소 간의 회대 거리를 최소가 되게끔 구하시오 = 휴게소 간 거리를 기준으로 이분탐색을 하세요 : 1477
