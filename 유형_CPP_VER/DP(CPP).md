# DP

- 반복되는 부분문제들(overlapping subproblem)의 연산 결과를 DP 테이블에 저장해 넣고 꺼내 쓰는 방식이다.

## DP 조건

### 중복 부분 문제 구조 속성 (overlapping subproblem)

- 작은 문제를 해결한 결과를 큰 문제를 해결하기 위해 사용할 수 있다.

### 최적 부분 문제 구조 속성 (optimal substructure)

- 어떤 문제의 해가 최적일 때, 그 해를 구성하는 작은 문제들의 해 역시 최적이다.

## 문제 해결 패턴

- 큰 문제를 작은 문제로 분할한다. (점화식을 세운다.)
- 부분문제들을 해결하여 DP 테이블에 저장한다.
- 추후에 해결한 부분 문제의 결과가 필요해지는 경우 DP 테이블에서 꺼내 사용한다.
    - 꺼내는 방식 1 : top - down 방식. DP 테이블에서 값을 꺼내는 시도를 수행한 다음, 값이 없다면 아래로 내려간다.
    - 꺼내는 방식 2 : bottom - up 방식. 아래에서부터 위로 거슬러 가며 값을 하나 하나 구해가는 방식이다.

## 문제 예시

###  1,2,3 더하기 [BOJ 9095] 

- DP[] : DP 테이블
- n번째 DP 값 : 1, 2, 3으로 n을 만드는 조합의 수

```cpp
DP[n] = DP[n-1] + DP[n-2] + DP[n-3];
```

### 계단 오르기 [BOJ 2579]

- DP[] : DP 테이블
- arr : 계단을 밟았을 때 점수
- n번째 DP 값 : n번째 계단을 밟았을 때의 점수 최댓값

```cpp
DP[n] = max(DP[n-3] + arr[n-1], DP[n-2]) + arr[n];
```

- DP[][] : DP 테이블
- arr : 계단을 밟았을 때 점수
- DP[i][j] : 현재까지 j계단을 연속해서 밟고 "i번째 계단까지 올라섰을 때" 점수 합의 최대값.

```cpp
// i-1번째 계단은 밟지 않았음. i-2번째 계단을 밟고 올라오는 수를 바탕으로 연산해주어야 함.
DP[i][1] = max(DP[i-2][1], DP[i-2][2]) + arr[i];

// i-1번째 계단을 밟았음. i-2번째까지 밟는다면 3개 연속 밟는다는 것에 위배. i-1번째를 바탕으로 연산해주어야 함.
DP[i][2] = DP[i-1][1] + arr[i];

// 마지막 최종 계단 n에 대한 결과 추출
max(DP[n][1], DP[n][2]);
```

### RGB거리 [BOJ 1149]

- DP[][] : DP 테이블
- arr[i][3] : i번째 집에 RGB 색 칠하는데 드는 비용
- DP[i][j] : i번째 집까지 색을 칠할때, i번째 집에 대해 j 번째 색을 사용하는데 드는 최송 비용

```cpp
DP[i][0] = min(DP[i-1][1], DP[i-1][2]) + RGB[i][0];
DP[i][1] = min(DP[i-1][0], DP[i-1][2]) + RGB[i][1];
DP[i][2] = min(DP[i-1][1], DP[i-1][0]) + RGB[i][2];
``` 

### 2\*N 타일링 [BOJ 11726]

- DP[] : DP 테이블
- DP[i] : i번째까지 1\*2 혹은 2\*1 타일로 채우는 방법의 수

```cpp
DP[i] = DP[i-1] + DP[i-2];
```

### 1로 만들기2 [BOJ 12852]

- DP[] : DP 테이블
- DP[i] : i를 만들기 위한 최소 카운팅 수

```cpp
DP[i] = DP[i-1] + 1;

if((i%2==0) && (DP[i] > DP[i/2] + 1)) DP[i] = DP[i/2] + 1;
if((i%3==0) && (DP[i] > DP[i/3] + 1)) DP[i] = DP[i/3] + 1;
```

### 알수없는 문장 [BOJ 1099]

- DP[n] : 문자열 n-1지점까지를 최소 갯수의 단어를 사용하여 조합하는 경우의 수

```cpp
DP[n+단어길이] = min(DP[n] + 단어끼리 일치하지 않는 글자의 수, DP[n+단어길이]);
```

### LIS [BOJ 11053]

- DP[n] : 숫자 n을 끝으로 하는 가장 긴 LIS 길이
- arr : 숫자 배열

```cpp
// arr의 이전 숫자들을 보며 갱신
for(int j=0; j<i; ++j) {
    if(tmp > arr[j]) DP[cur] = max(DP[cur], DP[arr[j]] + 1 );
}
```
